import ccxt
import pandas as pd
import time
from datetime import datetime
# from config import myconfig
import math
import pickle

# Binance test1
api_key = 'xxx'
secret = 'xxx'

# Binance test2
api_key = "xxx"
secret = "xxx"

# # gate
# api_key = 'xxx'
# secret = 'xxx'

# kraken
# api_key = 'xxx'
# secret = 'xxx'

exchange = ccxt.binance({
# exchange = ccxt.gateio({
# exchange = ccxt.kraken({
    # "apiKey": myconfig.API_KEY,
    # "secret": myconfig.API_SECRET
    "apiKey": api_key,
    "secret": secret
})

res_check = pd.DataFrame(columns = ['entry','type','base','INt','ticker','Profit'])

markets = exchange.fetchMarkets()
market_symbols = [market['symbol'] for market in markets]
print(f'No. of market symbols: {len(market_symbols)}')
print(f'Sample:{market_symbols[0:5]}')

def get_crypto_combinations(market_symbols, base):
    combinations = []
    for sym1 in market_symbols:
        
        sym1_token1 = sym1.split('/')[0]
        sym1_token2 = sym1.split('/')[1]
        
        if (sym1_token2 == base):
            for sym2 in market_symbols:
                sym2_token1 = sym2.split('/')[0]
                sym2_token2 = sym2.split('/')[1]
                if (sym1_token1 == sym2_token2):
                    for sym3 in market_symbols:
                        sym3_token1 = sym3.split('/')[0]
                        sym3_token2 = sym3.split('/')[1]
                        if((sym2_token1 == sym3_token1) and (sym3_token2 == sym1_token2)):
                            combination = {
                                'base':sym1_token2,
                                'intermediate':sym1_token1,
                                'ticker':sym2_token1,
                            }
                            combinations.append(combination)
                

    return combinations
        
wx_combinations_usdt = get_crypto_combinations(market_symbols,'USDT')
# wx_combinations_usdt = get_crypto_combinations(market_symbols,'BNB')

print(f'No. of crypto combinations: {len(wx_combinations_usdt)}')

cominations_df = pd.DataFrame(wx_combinations_usdt)
cominations_df.head()

def fetch_current_ticker_price(ticker, order_type):
    try:
        current_ticker_details = exchange.fetch_ticker(ticker)
    except ccxt.RequestTimeout as timeout_error:
        print("Error: Request timeout fetching ticker for: ", ticker)
    except ccxt.BaseError as other_error:
        print(f"Error fetching ticker for: {other_error}")
        
        print("Continuing with the rest of the code...")
    
    if order_type == 'sell_order':
        ticker_price = current_ticker_details['bid'] if current_ticker_details is not None else None
    else:
        ticker_price = current_ticker_details['ask'] if current_ticker_details is not None else None

    return ticker_price

def check_if_float_zero(value):
    return math.isclose(value, 0.0, abs_tol=1e-3)

def check_buy_buy_sell(scrip1, scrip2, scrip3,initial_investment):
    
    ## SCRIP1
    investment_amount1 = initial_investment
    current_price1 = fetch_current_ticker_price(scrip1, 'buy_order')
    final_price = 0
    scrip_prices = {}
    
    if current_price1 is not None and not check_if_float_zero(current_price1):
        buy_quantity1 = round(investment_amount1 / current_price1, 8)
        
        # TRY WITHOUT SLEEP IF THE EXCHANGE DOES NOT THROW RATE LIMIT EXCEPTIONS
        time.sleep(1)
        ## SCRIP2
        investment_amount2 = buy_quantity1     
        current_price2 = fetch_current_ticker_price(scrip2, 'buy_order')
        if current_price2 is not None and not check_if_float_zero(current_price2):
            buy_quantity2 = round(investment_amount2 / current_price2, 8)
            
            # TRY WITHOUT SLEEP IF THE EXCHANGE DOES NOT THROW RATE LIMIT EXCEPTIONS
            time.sleep(1)
            ## SCRIP3
            investment_amount3 = buy_quantity2     
            current_price3 = fetch_current_ticker_price(scrip3, 'sell_order')
            if current_price3 is not None and not check_if_float_zero(current_price3):
                sell_quantity3 = buy_quantity2
                final_price = round(sell_quantity3 * current_price3,3)
                scrip_prices = {scrip1 : current_price1, scrip2 : current_price2, scrip3 : current_price3}
                
    return final_price, scrip_prices

def check_buy_sell_sell(scrip1, scrip2, scrip3,initial_investment):
    ## SCRIP1
    investment_amount1 = initial_investment
    current_price1 = fetch_current_ticker_price(scrip1, 'buy_order')
    final_price = 0
    scrip_prices = {}
    if current_price1 is not None and not check_if_float_zero(current_price1):
        buy_quantity1 = round(investment_amount1 / current_price1, 8)
        
        # TRY WITHOUT SLEEP IF THE EXCHANGE DOES NOT THROW RATE LIMIT EXCEPTIONS
        time.sleep(1)
        ## SCRIP2
        investment_amount2 = buy_quantity1     
        current_price2 = fetch_current_ticker_price(scrip2, 'sell_order')
        if current_price2 is not None and not check_if_float_zero(current_price2):
            sell_quantity2 = buy_quantity1
            sell_price2 = round(sell_quantity2 * current_price2,8)
            
            # TRY WITHOUT SLEEP IF THE EXCHANGE DOES NOT THROW RATE LIMIT EXCEPTIONS
            time.sleep(1)
            ## SCRIP1
            investment_amount3 = sell_price2     
            current_price3 = fetch_current_ticker_price(scrip3, 'sell_order')
            if current_price3 is not None and not check_if_float_zero(current_price3):
                sell_quantity3 = sell_price2
                final_price = round(sell_quantity3 * current_price3,3)
                scrip_prices = {scrip1 : current_price1, scrip2 : current_price2, scrip3 : current_price3}
    return final_price,scrip_prices

def check_profit_loss(total_price_after_sell,initial_investment,transaction_brokerage, min_profit):
    apprx_brokerage = transaction_brokerage * initial_investment/100 * 3
    min_profitable_price = initial_investment + apprx_brokerage + min_profit
    profit_loss = round(total_price_after_sell - min_profitable_price,3)
    return profit_loss

def place_buy_order(scrip, quantity, limit):
    # order = exchange.create_limit_buy_order(scrip, quantity, limit)
    BL_Price = exchange.fetch_ticker(scrip)['ask']
    quantity = exchange.fetch_balance()['total'][limit]/BL_Price

    # quantity = exchange.fetch_balance()[limit].get('total')/exchange.fetch_ticker(scrip)['last']
    order = exchange.create_market_buy_order(scrip, quantity)
    # while True:
        # time.sleep(1)
    try:
        fetched_order = exchange.fetch_order(order['id'], scrip)
    
        if fetched_order['status'] == 'closed':
            print("BUY SUCCESS! - ", scrip)
            # print(fetched_order)
        # break
    except ccxt.BaseError as e:
        print("Error fetching order status:")
        print(e)
    
    # return order

def place_sell_order(scrip, quantity, limit):
    # order = exchange.create_limit_sell_order(scrip, quantity, limit)
    # quantity = exchange.fetch_balance()[limit].get('total')/exchange.fetch_ticker(scrip)['last']
    SL_Price = exchange.fetch_ticker(scrip)['bid']
    quantity = exchange.fetch_balance()['total'][limit] #/exchange.fetch_ticker(scrip)['bid']
    order = exchange.create_market_sell_order(scrip, quantity)
    # while True:
    #     time.sleep(1)
    try:
        fetched_order = exchange.fetch_order(order['id'], scrip)
    
        if fetched_order['status'] == 'closed':
            print("SELL SUCCESS! - ", scrip)
            # print(fetched_order)
            # break
    except ccxt.BaseError as e:
        print("Error fetching order status:")
        print(e)   
    
    # return order 

def place_trade_orders(type, scrip1, scrip2, scrip3, initial_amount, scrip_prices):
    final_amount = 0.0
    if type == 'BUY_BUY_SELL':
        s1_quantity = initial_amount/scrip_prices[scrip1]
        print('Quant1: ', s1_quantity)
        # place_buy_order(scrip1, s1_quantity, scrip_prices[scrip1])
        place_buy_order(scrip1, s1_quantity, base)
        
        s2_quantity = s1_quantity/scrip_prices[scrip2]
        print('Quant2: ', s2_quantity)
        # place_buy_order(scrip2, s2_quantity, scrip_prices[scrip2])
        place_buy_order(scrip2, s2_quantity, intermediate)
        
        s3_quantity = s2_quantity
        print('Quant3: ', s3_quantity)
        # place_sell_order(scrip3, s3_quantity, scrip_prices[scrip3])
        place_sell_order(scrip3, s3_quantity, ticker)
        
    elif type == 'BUY_SELL_SELL':
        s1_quantity = initial_amount/scrip_prices[scrip1]
        print('Quant1: ', s1_quantity)
        # place_buy_order(scrip1, s1_quantity, scrip_prices[scrip1])
        place_buy_order(scrip1, s1_quantity, base)
        
        s2_quantity = s1_quantity
        print('Quant2: ', s2_quantity)
        # place_sell_order(scrip2, s2_quantity, scrip_prices[scrip2])
        place_sell_order(scrip2, s2_quantity, ticker)
        
        
        s3_quantity = s2_quantity * scrip_prices[scrip2]
        print('Quant3: ', s3_quantity)
        # place_sell_order(scrip3, s3_quantity, scrip_prices[scrip3])
        place_sell_order(scrip3, s3_quantity, intermediate)
        
        
    return final_amount

def perform_triangular_arbitrage(scrip1, scrip2, scrip3, arbitrage_type,initial_investment, 
                               transaction_brokerage, min_profit):
    final_price = 0.0
    if(arbitrage_type == 'BUY_BUY_SELL'):
        # Check this combination for triangular arbitrage: scrip1 - BUY, scrip2 - BUY, scrip3 - SELL
        final_price, scrip_prices = check_buy_buy_sell(scrip1, scrip2, scrip3,initial_investment)
        
    elif(arbitrage_type == 'BUY_SELL_SELL'):
        # Check this combination for triangular arbitrage: scrip1 - BUY, scrip2 - SELL, scrip3 - SELL
        final_price, scrip_prices = check_buy_sell_sell(scrip1, scrip2, scrip3,initial_investment)
        
    profit_loss = check_profit_loss(final_price,initial_investment, transaction_brokerage, min_profit)
    
    # print(f"PROFIT-{datetime.now().strftime('%H:%M:%S')}:"\
    #           f"{arbitrage_type}, {scrip1},{scrip2},{scrip3}, Profit/Loss: {round(final_price-initial_investment,3)} ")
    
    print(f"PROFIT-{datetime.now().strftime('%H:%M:%S')}:"\
              f"{arbitrage_type}, {scrip1},{scrip2},{scrip3}, Profit/Loss: {profit_loss} ")
    
    # res_check = pd.DataFrame(columns = ['entry','type','base','INt','ticker','Profit'])
    new_row = {'entry' : datetime.now().strftime('%H:%M:%S'), 
                   'type' : arbitrage_type, 'base' : scrip1, 'INt' : scrip2, 'ticker' : scrip3, 
                   'Profit' : profit_loss}
    # res_check = res_check.append(new_row, ignore_index = True)
    
    if profit_loss>0:
        print(f"!!! PROFIT-{datetime.now().strftime('%H:%M:%S')}:"\
              f"{arbitrage_type}, {scrip1},{scrip2},{scrip3}, Profit/Loss: {profit_loss} ")
        
        # UNCOMMENT THIS LINE TO PLACE THE ORDERS
        place_trade_orders(arbitrage_type, scrip1, scrip2, scrip3, initial_investment, scrip_prices)
        
    return new_row
        
INVESTMENT_AMOUNT_DOLLARS = 100
# MIN_PROFIT_DOLLARS = 0.5
# BROKERAGE_PER_TRANSACTION_PERCENT = 0.2

MIN_PROFIT_DOLLARS = 0.1
BROKERAGE_PER_TRANSACTION_PERCENT = 0.2

# Upload known combinations with opportunities from a csv pickle. Comment out
with open('wx1.pkl', 'rb') as f:
    wx_combinations_usdt = pickle.load(f)


# UNCOMMENT THE WHILE LOOP TO RUN THIS LOOP CONTINUOUSLY
while(1):
    for combination in wx_combinations_usdt:
    
        base = combination['base']
        intermediate = combination['intermediate']
        ticker = combination['ticker']
    
    
        s1 = f'{intermediate}/{base}'    # Eg: BTC/USDT
        s2 = f'{ticker}/{intermediate}'  # Eg: ETH/BTC
        s3 = f'{ticker}/{base}'          # Eg: ETH/USDT 
    
        # Check triangular arbitrage for buy-buy-sell 
        new_row = perform_triangular_arbitrage(s1,s2,s3,'BUY_BUY_SELL',INVESTMENT_AMOUNT_DOLLARS,
                                  BROKERAGE_PER_TRANSACTION_PERCENT, MIN_PROFIT_DOLLARS)
        # res_check = pd.concat([res_check,pd.DataFrame(new_row)])
        res_check = res_check.append(new_row, ignore_index = True)

        
        # Sleep to avoid rate limit on api calls (RateLimitExceeded exception)
        time.sleep(1) 
        # Check triangular arbitrage for buy-sell-sell 
        new_row = perform_triangular_arbitrage(s3,s2,s1,'BUY_SELL_SELL',INVESTMENT_AMOUNT_DOLLARS,
                                  BROKERAGE_PER_TRANSACTION_PERCENT, MIN_PROFIT_DOLLARS)
        
        res_check = res_check.append(new_row, ignore_index = True)
        # res_check = pd.concat([res_check,pd.DataFrame(new_row)])
        time.sleep(1)    





